<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="熔断器 #  包 core/break 提供了一个熔断器的接口和两套实现。
什么是 熔断器？ #  服务端经常会面临的一个问题是服务器负载过高，比如某个热点新闻导致流量短时间激增，这个时候如果不做相应的保护，服务端可能发生宕机导致直接不可用。处理这种情况一般会：
 服务降级：比如返回静态数据 服务熔断：对部分请求直接返回服务不可用，对其他请求继续提供服务  熔断器就是完成熔断功能的组件。它应该决定是否为当前请求提供正常服务，还是直接拒绝。
go-zero熔断器的实现 #  接口定义 #  type ( // 判断一个错误返回是否依旧是成功的 	Acceptable func(err error) bool Breaker interface { // Name returns the name of the netflixBreaker. 	Name() string // 判断请求是否被允许  // 如果允许，调用方需要在调用成功后调用 promise.Accept(),失败后调用 promise.Reject  // 如果不被允许（限流了），返回的是 ErrServiceUnavailable 	Allow() (Promise, error) // DoWithFallbackAcceptable  // - 在未被限流时执行req  // - 被限流时执行fallback（回退） 	// - acceptable 检查 req 是否调用成功，即便req返回的err不是nil 	DoWithFallbackAcceptable(req func() error, fallback func(err error) error, acceptable Acceptable) error // DoWithFallbackAcceptable 的简化版  // acceptable 为 err == nil 	DoWithFallback(req func() error, fallback func(err error) error) error // DoWithFallbackAcceptable 的简化版  // fallback 逻辑为：nil 不做回退 	DoWithAcceptable(req func() error, acceptable Acceptable) error // DoWithFallbackAcceptable 的简化版  // acceptable 为 err == nil  // fallback 逻辑为：nil 不做回退 	Do(req func() error) error } ) 可以看见，类库实现的Breaker里面本质上只有两个接口：">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="熔断器 #  包 core/break 提供了一个熔断器的接口和两套实现。
什么是 熔断器？ #  服务端经常会面临的一个问题是服务器负载过高，比如某个热点新闻导致流量短时间激增，这个时候如果不做相应的保护，服务端可能发生宕机导致直接不可用。处理这种情况一般会：
 服务降级：比如返回静态数据 服务熔断：对部分请求直接返回服务不可用，对其他请求继续提供服务  熔断器就是完成熔断功能的组件。它应该决定是否为当前请求提供正常服务，还是直接拒绝。
go-zero熔断器的实现 #  接口定义 #  type ( // 判断一个错误返回是否依旧是成功的 	Acceptable func(err error) bool Breaker interface { // Name returns the name of the netflixBreaker. 	Name() string // 判断请求是否被允许  // 如果允许，调用方需要在调用成功后调用 promise.Accept(),失败后调用 promise.Reject  // 如果不被允许（限流了），返回的是 ErrServiceUnavailable 	Allow() (Promise, error) // DoWithFallbackAcceptable  // - 在未被限流时执行req  // - 被限流时执行fallback（回退） 	// - acceptable 检查 req 是否调用成功，即便req返回的err不是nil 	DoWithFallbackAcceptable(req func() error, fallback func(err error) error, acceptable Acceptable) error // DoWithFallbackAcceptable 的简化版  // acceptable 为 err == nil 	DoWithFallback(req func() error, fallback func(err error) error) error // DoWithFallbackAcceptable 的简化版  // fallback 逻辑为：nil 不做回退 	DoWithAcceptable(req func() error, acceptable Acceptable) error // DoWithFallbackAcceptable 的简化版  // acceptable 为 err == nil  // fallback 逻辑为：nil 不做回退 	Do(req func() error) error } ) 可以看见，类库实现的Breaker里面本质上只有两个接口：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/SCA/docs/tal-tech_go-zero/core/02_break/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2022-02-04T12:26:06+08:00" />

<title>02 Break | SourceCodeAnalysis</title>
<link rel="manifest" href="/SCA/manifest.json">
<link rel="icon" href="/SCA/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/SCA/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css" >
  <script defer src="/SCA/flexsearch.min.js"></script>
  <script defer src="/SCA/en.search.min.86e95a8997e1eb2108ee7716c64b319afdcbc5bb8f54772bf3d3b8fabe82073f.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/SCA/"><span>SourceCodeAnalysis</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-068369a7839e687a60defc326c6ae3b1" class="toggle"  />
    <label for="section-068369a7839e687a60defc326c6ae3b1" class="flex justify-between">
      <a role="button" class="">gin-gonic/gin</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0001_preface/" class="">0001 Preface</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0101_flow/" class="">0101 Flow</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0200/" class="">200th</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0201_router/" class="">0201 Router</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0202_radix_tree/" class="">0202 Radix Tree</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0301_request/" class="">0301 Request</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0401_response/" class="">0401 Response</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0501_other/" class="">0501 Other</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6e8bbf282ebf66cf249a9e198c334299" class="toggle" checked />
    <label for="section-6e8bbf282ebf66cf249a9e198c334299" class="flex justify-between">
      <a role="button" class="">tal-tech/go-zero</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2ca4f21c93ca8ec9f0714b747485f1a5" class="toggle" checked />
    <label for="section-2ca4f21c93ca8ec9f0714b747485f1a5" class="flex justify-between">
      <a role="button" class="">Core</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/01_bloom_filter/" class="">01 Bloom Filter</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/02_break/" class=" active">02 Break</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/03_collection/" class="">03 Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/04_executor/" class="">04 Executor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/05_fx/" class="">05 Fx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/06_hash/" class="">06 Hash</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/09_other/" class="">09 Other</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/SCA/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>02 Break</strong>

  <label for="toc-control">
    
    <img src="/SCA/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#熔断器">熔断器</a>
      <ul>
        <li>
          <ul>
            <li><a href="#什么是-熔断器">什么是 熔断器？</a></li>
            <li><a href="#go-zero熔断器的实现">go-zero熔断器的实现</a></li>
            <li><a href="#延展">延展</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="熔断器">
  熔断器
  <a class="anchor" href="#%e7%86%94%e6%96%ad%e5%99%a8">#</a>
</h1>
<p>包 <code>core/break</code> 提供了一个熔断器的接口和两套实现。</p>
<h3 id="什么是-熔断器">
  什么是 熔断器？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-%e7%86%94%e6%96%ad%e5%99%a8">#</a>
</h3>
<p>服务端经常会面临的一个问题是服务器负载过高，比如某个热点新闻导致流量短时间激增，这个时候如果不做相应的保护，服务端可能发生宕机导致直接不可用。处理这种情况一般会：</p>
<ul>
<li>服务降级：比如返回静态数据</li>
<li>服务熔断：对部分请求直接返回服务不可用，对其他请求继续提供服务</li>
</ul>
<p>熔断器就是完成熔断功能的组件。它应该决定是否为当前请求提供正常服务，还是直接拒绝。</p>
<h3 id="go-zero熔断器的实现">
  go-zero熔断器的实现
  <a class="anchor" href="#go-zero%e7%86%94%e6%96%ad%e5%99%a8%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h3>
<h4 id="接口定义">
  接口定义
  <a class="anchor" href="#%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> (
  <span style="color:#75715e">// 判断一个错误返回是否依旧是成功的
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Acceptable</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span>

	<span style="color:#a6e22e">Breaker</span> <span style="color:#66d9ef">interface</span> {
		<span style="color:#75715e">// Name returns the name of the netflixBreaker.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">Name</span>() <span style="color:#66d9ef">string</span>

    <span style="color:#75715e">// 判断请求是否被允许
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果允许，调用方需要在调用成功后调用 promise.Accept(),失败后调用 promise.Reject
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果不被允许（限流了），返回的是 ErrServiceUnavailable
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">Allow</span>() (<span style="color:#a6e22e">Promise</span>, <span style="color:#66d9ef">error</span>)

		<span style="color:#75715e">// DoWithFallbackAcceptable 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - 在未被限流时执行req
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// - 被限流时执行fallback（回退）
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// - acceptable 检查 req 是否调用成功，即便req返回的err不是nil
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">DoWithFallbackAcceptable</span>(<span style="color:#a6e22e">req</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">fallback</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">acceptable</span> <span style="color:#a6e22e">Acceptable</span>) <span style="color:#66d9ef">error</span>
    
		<span style="color:#75715e">// DoWithFallbackAcceptable 的简化版
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// acceptable 为 err == nil
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">DoWithFallback</span>(<span style="color:#a6e22e">req</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">fallback</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">error</span>
    
		<span style="color:#75715e">// DoWithFallbackAcceptable 的简化版
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fallback 逻辑为：nil 不做回退
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">DoWithAcceptable</span>(<span style="color:#a6e22e">req</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">acceptable</span> <span style="color:#a6e22e">Acceptable</span>) <span style="color:#66d9ef">error</span>

    
		<span style="color:#75715e">// DoWithFallbackAcceptable 的简化版
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// acceptable 为 err == nil
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fallback 逻辑为：nil 不做回退
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">req</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">error</span>
	}
)
</code></pre></div><p>可以看见，类库实现的Breaker里面本质上只有两个接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 判断是否被限流
</span><span style="color:#75715e"></span><span style="color:#a6e22e">Allow</span>() (<span style="color:#a6e22e">Promise</span>, <span style="color:#66d9ef">error</span>)

<span style="color:#75715e">// 确定是否被限流
</span><span style="color:#75715e">// - 如果限流了就执行 fallback
</span><span style="color:#75715e">// - 如果没有限流就执行 req，使用 acceptable 确定是否执行成功，来执行后续的行为（本质上是Promise）
</span><span style="color:#75715e"></span><span style="color:#a6e22e">DoWithFallbackAcceptable</span>(<span style="color:#a6e22e">req</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">fallback</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">acceptable</span> <span style="color:#a6e22e">Acceptable</span>) <span style="color:#66d9ef">error</span>
</code></pre></div><h4 id="功能实现原理">
  功能实现原理
  <a class="anchor" href="#%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h4>
<p>实现是参考了<a href="https://landing.google.com/sre/sre-book/chapters/handling-overload/">Google的方案</a>。先对方案进行阐述：</p>
<p>A通过调用Redis完成自身业务，因为Redis的负载是有限的，一般会和A协商好Redis对A的容量，如果超限了就拒绝对A的调用。</p>
<p>这里面有个问题，拒绝服务会耗用资源，比如：</p>
<ul>
<li>如果提供服务的代价比拒绝服务的代价还要小</li>
<li>如果请求太多了，拒绝本身也很昂贵</li>
</ul>
<p>Google给出个他们实践下来效果良好的方案<code>自适应限流</code>：在Redis被访问时（这个逻辑A中调用，但是由Redis客户端类库提供）Redis客户端库自己会在Redis服务拒绝后开始按一定比例直接丢弃A对Redis的请求（连网络请求都不发送）。</p>
<p>丢弃的概率为： <code>max(0, (一段时间内的请求总数 - K * 一段时间内的请求被正常处理数) / (一段时间内的请求总数 + 1) )</code></p>
<p>其中K是一个变量，举个例子，当K = 1 时，一个请求会有 (被拒绝的数量 / 总数量) 的概率直接被拒绝，假设Redis能处理 200 个请求：</p>
<ol>
<li>当请求数量为200时，被拒绝的概率是0，被处理的数量为200</li>
<li>当请求数量为400时，Redis服务端会拒绝200个请求，可以得到被拒绝的概率是0.5，这时候类库会开始将200个请求直接丢弃掉，下一刻又回到 状态1</li>
</ol>
<p>这是个静态的估计，实际中请求总数是动态变化的，被拒绝的数量也是变化的。</p>
<p>K的含义是：K越大，被拒绝的概率就越小，后端的压力就会越大。</p>
<p>Google使用K=2，期望服务端能够正常处理请求。</p>
<p>注意，这个算法在零星请求的情况下表现得不好，当请求量开始增加时，服务端的反馈会感觉过慢。</p>
<h4 id="功能实现细节">
  功能实现细节
  <a class="anchor" href="#%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">#</a>
</h4>
<p>知道了原理，实现细节就很好理解了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">googleBreaker</span>) <span style="color:#a6e22e">accept</span>() <span style="color:#66d9ef">error</span> {
  <span style="color:#75715e">// 从 RollingWindow 中得到当前的情况
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">accepts</span>, <span style="color:#a6e22e">total</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">history</span>() 
  <span style="color:#75715e">// k = 1.5
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">weightedAccepts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">k</span> <span style="color:#f92672">*</span> float64(<span style="color:#a6e22e">accepts</span>)
  
  <span style="color:#75715e">// protection = 5,做预留了,得到丢弃概率
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// https://landing.google.com/sre/sre-book/chapters/handling-overload/#eq2101
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dropRatio</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Max</span>(<span style="color:#ae81ff">0</span>, (float64(<span style="color:#a6e22e">total</span><span style="color:#f92672">-</span><span style="color:#a6e22e">protection</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">weightedAccepts</span>)<span style="color:#f92672">/</span>float64(<span style="color:#a6e22e">total</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
  
  <span style="color:#75715e">// 丢弃概率为0，确保当前的限流状态是关闭的
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dropRatio</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#75715e">// 直接返回 接受请求
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	}
  
  <span style="color:#75715e">// 按概率进行丢弃
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">proba</span>.<span style="color:#a6e22e">TrueOnProba</span>(<span style="color:#a6e22e">dropRatio</span>) {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ErrServiceUnavailable</span>
	}

	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
</code></pre></div><h3 id="延展">
  延展
  <a class="anchor" href="#%e5%bb%b6%e5%b1%95">#</a>
</h3>
<p>限流器处理Google的这个自适应的解决方案，还包括几个经典的方案：</p>
<ul>
<li>
<p>固定窗口：最直接的解决方案，计算周期内总数，超了就限流</p>
<ul>
<li>计数周期太大会导致误差，比如周期为1秒，那么在1秒内相隔的两毫秒的流量可以是最大限流的两倍</li>
</ul>
<p><img src="../imgs/fix_window.png" alt="" /></p>
</li>
<li>
<p>滑动窗口：是计数器的升级版，将计算周期减小，使用多个计数器</p>
</li>
</ul>
<p><img src="../imgs/rolling_window.png" alt="" /></p>
<ul>
<li>令牌桶：令牌已一定的速度落入桶里面，请求过来时拿一个，如果没拿到就是被限流了</li>
</ul>
<p><img src="../imgs/token.png" alt="" /></p>
<ul>
<li>漏斗：将所有的请求排队，从漏斗里面一一出来</li>
</ul>
<p><img src="../imgs/leaky_bucket.png" alt="" /></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/liuximu/sca/commit/23798e30c49011a9640888a75e958ff71b5140de" title='Last modified by liuximu | 2022/02/04' target="_blank" rel="noopener">
      <img src="/SCA/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>2022/02/04</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/liuximu/sca/edit/master/content/docs/tal-tech_go-zero/core/02_break.md" target="_blank" rel="noopener">
      <img src="/SCA/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#熔断器">熔断器</a>
      <ul>
        <li>
          <ul>
            <li><a href="#什么是-熔断器">什么是 熔断器？</a></li>
            <li><a href="#go-zero熔断器的实现">go-zero熔断器的实现</a></li>
            <li><a href="#延展">延展</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












