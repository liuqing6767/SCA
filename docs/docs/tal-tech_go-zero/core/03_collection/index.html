<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="集合 #  包 core/collection 实现了各种典型集合类型
RollingWindow #  限流的方案在 熔断器 里面讲过，Rolling Window 就是一个经典的算法。
为了解决计算一段时间Interval的请求次数，滑动窗口算法的做法为：将计算周期切成N个Bucket，每个请求过来后，将请求放入对应的Bucket中，当要计算window有多少个请求时，把相关所有的bucket的数据累计起来即可。
我们先看看数据结构定义：
type RollingWindow struct { lock sync.RWMutex // 有多少个计数器 size int // 每个计算器的计数周期 interval time.Duration // 窗口，由多个Bucket组成 win *window // 窗口的偏移，范围为 [0, size) offset int // 最后一次更新的时间 lastTime time.Duration ignoreCurrent bool } type window struct { buckets []*Bucket // 一个window有多个Bucket size int } type Bucket struct { Sum float64 Count int64 } 我们再看看行为定义：
// 添加个数 func (rw *RollingWindow) Add(v float64) // 通过这个函数拿到当前的状态 // 会找到多个Bucket，需要总数的话直接累加即可 func (rw *RollingWindow) Reduce(fn func(b *Bucket)) 其实算法也不是那么的高深，一个滑动窗口由多个bucket组成：">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="" />
<meta property="og:description" content="集合 #  包 core/collection 实现了各种典型集合类型
RollingWindow #  限流的方案在 熔断器 里面讲过，Rolling Window 就是一个经典的算法。
为了解决计算一段时间Interval的请求次数，滑动窗口算法的做法为：将计算周期切成N个Bucket，每个请求过来后，将请求放入对应的Bucket中，当要计算window有多少个请求时，把相关所有的bucket的数据累计起来即可。
我们先看看数据结构定义：
type RollingWindow struct { lock sync.RWMutex // 有多少个计数器 size int // 每个计算器的计数周期 interval time.Duration // 窗口，由多个Bucket组成 win *window // 窗口的偏移，范围为 [0, size) offset int // 最后一次更新的时间 lastTime time.Duration ignoreCurrent bool } type window struct { buckets []*Bucket // 一个window有多个Bucket size int } type Bucket struct { Sum float64 Count int64 } 我们再看看行为定义：
// 添加个数 func (rw *RollingWindow) Add(v float64) // 通过这个函数拿到当前的状态 // 会找到多个Bucket，需要总数的话直接累加即可 func (rw *RollingWindow) Reduce(fn func(b *Bucket)) 其实算法也不是那么的高深，一个滑动窗口由多个bucket组成：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/SCA/docs/tal-tech_go-zero/core/03_collection/" /><meta property="article:section" content="docs" />

<meta property="article:modified_time" content="2022-02-04T11:38:06+08:00" />

<title>03 Collection | SourceCodeAnalysis</title>
<link rel="manifest" href="/SCA/manifest.json">
<link rel="icon" href="/SCA/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/SCA/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css" >
  <script defer src="/SCA/flexsearch.min.js"></script>
  <script defer src="/SCA/en.search.min.86e95a8997e1eb2108ee7716c64b319afdcbc5bb8f54772bf3d3b8fabe82073f.js" ></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/SCA/"><span>SourceCodeAnalysis</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-068369a7839e687a60defc326c6ae3b1" class="toggle"  />
    <label for="section-068369a7839e687a60defc326c6ae3b1" class="flex justify-between">
      <a role="button" class="">gin-gonic/gin</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0001_preface/" class="">0001 Preface</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0101_flow/" class="">0101 Flow</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0200/" class="">200th</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0201_router/" class="">0201 Router</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0202_radix_tree/" class="">0202 Radix Tree</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0301_request/" class="">0301 Request</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0401_response/" class="">0401 Response</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/gin-gonic_gin/0501_other/" class="">0501 Other</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6e8bbf282ebf66cf249a9e198c334299" class="toggle" checked />
    <label for="section-6e8bbf282ebf66cf249a9e198c334299" class="flex justify-between">
      <a role="button" class="">tal-tech/go-zero</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2ca4f21c93ca8ec9f0714b747485f1a5" class="toggle" checked />
    <label for="section-2ca4f21c93ca8ec9f0714b747485f1a5" class="flex justify-between">
      <a role="button" class="">Core</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/01_bloom_filter/" class="">01 Bloom Filter</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/02_break/" class="">02 Break</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/03_collection/" class=" active">03 Collection</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/04_executor/" class="">04 Executor</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/05_fx/" class="">05 Fx</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/06_hash/" class="">06 Hash</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/SCA/docs/tal-tech_go-zero/core/09_other/" class="">09 Other</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/SCA/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>03 Collection</strong>

  <label for="toc-control">
    
    <img src="/SCA/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#集合">集合</a>
      <ul>
        <li>
          <ul>
            <li><a href="#rollingwindow">RollingWindow</a></li>
            <li><a href="#timingwheel">TimingWheel</a></li>
            <li><a href="#safemap">SafeMap</a></li>
            <li><a href="#set">Set</a></li>
            <li><a href="#ring">Ring</a></li>
            <li><a href="#queue">Queue</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="集合">
  集合
  <a class="anchor" href="#%e9%9b%86%e5%90%88">#</a>
</h1>
<p>包 <code>core/collection</code> 实现了各种典型集合类型</p>
<h3 id="rollingwindow">
  RollingWindow
  <a class="anchor" href="#rollingwindow">#</a>
</h3>
<p>限流的方案在 <a href="./02_break.md">熔断器</a> 里面讲过，Rolling Window 就是一个经典的算法。</p>
<p>为了解决计算一段时间Interval的请求次数，滑动窗口算法的做法为：将计算周期切成N个Bucket，每个请求过来后，将请求放入对应的Bucket中，当要计算window有多少个请求时，把相关所有的bucket的数据累计起来即可。</p>
<p>我们先看看数据结构定义：</p>
<pre tabindex="0"><code>type RollingWindow struct {
	lock          sync.RWMutex
	// 有多少个计数器
	size          int
	// 每个计算器的计数周期
	interval      time.Duration
	
	// 窗口，由多个Bucket组成
	win           *window
	
	// 窗口的偏移，范围为 [0, size)
	offset        int
	// 最后一次更新的时间
	lastTime      time.Duration
	
	ignoreCurrent bool
}
	
type window struct {
	buckets []*Bucket // 一个window有多个Bucket
	size    int
}

type Bucket struct {
	Sum   float64
	Count int64
}
</code></pre><p>我们再看看行为定义：</p>
<pre tabindex="0"><code>// 添加个数
func (rw *RollingWindow) Add(v float64) 

// 通过这个函数拿到当前的状态
// 会找到多个Bucket，需要总数的话直接累加即可
func (rw *RollingWindow) Reduce(fn func(b *Bucket))
</code></pre><p>其实算法也不是那么的高深，一个滑动窗口由多个bucket组成：</p>
<ul>
<li>每次往窗口里面添加时：清理过期的bucket后找到目标bucket加入</li>
<li>每次要看窗口的个数是：找到目标的bucket列表，依次查看其Sum和Count即可</li>
</ul>
<p>假设需求是一分钟限流60次，创建一个size为6，interval为10s的滑动窗口对象。</p>
<table>
<thead>
<tr>
<th>时间，行为</th>
<th>总数<!-- raw HTML omitted --> Count/Sum</th>
<th>第0个<!-- raw HTML omitted -->bucket<!-- raw HTML omitted --> Count/Sum</th>
<th>第1个</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>第8s，新增20个请求</td>
<td>20 / 20</td>
<td>20 / 20</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
</tr>
<tr>
<td>第18s，新增10个请求</td>
<td>30 / 30</td>
<td>20 / 20</td>
<td>10 / 10</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
</tr>
<tr>
<td>第58s，新增15个请求</td>
<td>45 / 45</td>
<td>20 / 20</td>
<td>10 / 10</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>15 / 15</td>
</tr>
<tr>
<td>第78s，新增25个请求</td>
<td></td>
<td>0 / 0</td>
<td>25 / 25</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>0 / 0</td>
<td>15 / 15</td>
</tr>
</tbody>
</table>
<h3 id="timingwheel">
  TimingWheel
  <a class="anchor" href="#timingwheel">#</a>
</h3>
<p>对于延迟执行任务，TimingWheel是一个常用的数据结构。一般而言，时间轮会有一个时间间隔，每多久执行一次。然后往里面加任务，一般任务会有一个delay的属性，表示延时多久执行</p>
<p><img src="/Users/liuqing18/Documents/Artist/golang/src/github.com/liuximu/SCA/tal-tech_go-zero/imgs/TimingWheel.png" alt="TimingWheel" /></p>
<p>每个时间轮会有多个槽点，每个槽点对应的是一个任务列表。每过一个时间间隔，就去执行下一个槽点对应的任务。</p>
<p>我们先看看每个任务的数据结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">timingEntry</span> <span style="color:#66d9ef">struct</span> {
		<span style="color:#a6e22e">baseEntry</span>
		<span style="color:#a6e22e">value</span>   <span style="color:#66d9ef">interface</span>{}
    
		<span style="color:#a6e22e">circle</span>  <span style="color:#66d9ef">int</span>
		<span style="color:#a6e22e">diff</span>    <span style="color:#66d9ef">int</span>
		<span style="color:#a6e22e">removed</span> <span style="color:#66d9ef">bool</span>
	}

	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">baseEntry</span> <span style="color:#66d9ef">struct</span> {
		<span style="color:#75715e">// 延迟多长时间执行
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">delay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
		<span style="color:#75715e">// 任务的key
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">key</span>   <span style="color:#66d9ef">interface</span>{}
	}
</code></pre></div><p>每个任务包括：</p>
<ul>
<li>circle(层)，如果circle==0，那就是当前执行，不然circle&ndash;，继续等待机会。</li>
<li>在实现细节上，任务还包含diff属性，是移动任务是的偏移量，在被执行时如果diff&gt;0，就需要移动到后面的槽点（这个设计是为了简化移动任务的实现复杂度）</li>
</ul>
<p>我们看看类库的实现。</p>
<p>时间轮的基本数据结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimingWheel</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#75715e">// 多长时间触发一次
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">interval</span>      <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>
    <span style="color:#75715e">// 内置的定时器
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ticker</span>        <span style="color:#a6e22e">timex</span>.<span style="color:#a6e22e">Ticker</span>
    
    <span style="color:#75715e">// 槽点的个数
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">numSlots</span>      <span style="color:#66d9ef">int</span>
    <span style="color:#75715e">// 个数为numSolts的槽点列表
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">slots</span>         []<span style="color:#f92672">*</span><span style="color:#a6e22e">list</span>.<span style="color:#a6e22e">List</span>
    
    <span style="color:#75715e">// 一个冗余数据，任务的key为key，为了确认同名的任务是否已经存在
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">timers</span>        <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeMap</span>
    
    <span style="color:#75715e">// 当前的位置
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">tickedPos</span>     <span style="color:#66d9ef">int</span>
		<span style="color:#a6e22e">execute</span>       <span style="color:#a6e22e">Execute</span>
		<span style="color:#a6e22e">setChannel</span>    <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">timingEntry</span>
		<span style="color:#a6e22e">moveChannel</span>   <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">baseEntry</span>
    
    <span style="color:#75715e">// 标识任务被删除的chan
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">removeChannel</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">interface</span>{}
    <span style="color:#75715e">// 标识任务被放弃执行
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">drainChannel</span>  <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">interface</span>{})
    
    <span style="color:#75715e">// 标识停止的chan
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">stopChannel</span>   <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">lang</span>.<span style="color:#a6e22e">PlaceholderType</span>
	}
</code></pre></div><p>时间轮的行为包括：</p>
<ul>
<li>新增一个任务</li>
<li>往后移动一个任务</li>
<li>删除一个任务</li>
<li>清空时间轮</li>
<li>停止时间轮</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 添加/更新任务， 同步操作是写入setChannel
</span><span style="color:#75715e">// 异步操作是：
</span><span style="color:#75715e">//  如果任务存在（timer这个冗余的数据结构），进行更新存在
</span><span style="color:#75715e">//  任务不存在，将其加入对应的槽点的任务列表中即可
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TimingWheel</span>) <span style="color:#a6e22e">SetTimer</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">delay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) 

<span style="color:#75715e">// 移动任务，往后延迟被执行的时间，同步操作是写入 moveChannel
</span><span style="color:#75715e">// 如果delay（后移的时间）小于interval，直接执行
</span><span style="color:#75715e">// 不然，将任务移动到适当的position和circle
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TimingWheel</span>) <span style="color:#a6e22e">MoveTimer</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">delay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>)

<span style="color:#75715e">// 移除任务，同步操作是写入 removeChannel
</span><span style="color:#75715e">// 异步实现是将 timers 中对应的任务直接设置为 removed
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TimingWheel</span>) <span style="color:#a6e22e">RemoveTimer</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">interface</span>{}) 

<span style="color:#75715e">// 放弃执行，同步操作是写入drainChannel
</span><span style="color:#75715e">// 异步实现是将solts的每个元素拿出来（是一个列表），依次将每个结点的key和value交个fn执行，然后删除节点
</span><span style="color:#75715e">// 执行完成后，slots的每个元素都是空数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TimingWheel</span>) <span style="color:#a6e22e">Drain</span>(<span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">interface</span>{})) 

<span style="color:#75715e">// 停止，同步操作是关闭 stopChannel
</span><span style="color:#75715e">// 异步操作是停止 ticker
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TimingWheel</span>) <span style="color:#a6e22e">Stop</span>()
</code></pre></div><p>最重要的操作 其实是每次 ticker 被触发时的任务处理逻辑：
先得到当前的槽点： (tickedPos + 1) % numSlots，得到一个链表
对链表的每个元素依次处理：</p>
<ul>
<li>如果任务已经被设置为removed，直接移除即可</li>
<li>如果circle&gt;0，circle&ndash;，退出处理（说明它不再本周期）</li>
<li>如果diff大于0，找到合适的位置，加入，把本节点删除（其实是move的后续操作）</li>
<li>这时候就是是时候开始执行任务了</li>
</ul>
<p>时间轮被创建后，异步就开始监听各个chan来执行上面的逻辑了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">tw</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TimingWheel</span>) <span style="color:#a6e22e">run</span>() {
	<span style="color:#66d9ef">for</span> {
		<span style="color:#66d9ef">select</span> {
    <span style="color:#75715e">// 任务执行定时器
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">Chan</span>(): 
			<span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">onTick</span>()
    <span style="color:#75715e">// 任务添加/更新
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">task</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">setChannel</span>: 
			<span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">setTask</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">task</span>)
    <span style="color:#75715e">// 任务删除
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">removeChannel</span>:
			<span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">removeTask</span>(<span style="color:#a6e22e">key</span>)
    <span style="color:#75715e">// 任务往后移动
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">task</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">moveChannel</span>: 
			<span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">moveTask</span>(<span style="color:#a6e22e">task</span>)
    <span style="color:#75715e">// 任务全部清空
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">fn</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">drainChannel</span>: 
			<span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">drainAll</span>(<span style="color:#a6e22e">fn</span>)
    <span style="color:#75715e">// 停止
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">stopChannel</span>: 
			<span style="color:#a6e22e">tw</span>.<span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">Stop</span>()
			<span style="color:#66d9ef">return</span>
		}
	}
}
</code></pre></div><h3 id="safemap">
  SafeMap
  <a class="anchor" href="#safemap">#</a>
</h3>
<p>golang 里面的map是非并发安全的，并发读写map会panic。官方库提供了 sync.Map 可以直接使用。</p>
<p>类库提供的 safemap 除了通过加锁解决并发的问题，还解决了一个官方库某些版本才有的<a href="https://github.com/golang/go/issues/20135">bug</a>。</p>
<p>本身应该能用到的地方不多，但还是简单分析一下思路。</p>
<p>safe map 定义和接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SafeMap</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">lock</span>        <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
	<span style="color:#a6e22e">deletionOld</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">deletionNew</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">dirtyOld</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">dirtyNew</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeMap</span>) <span style="color:#a6e22e">Del</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">interface</span>{})
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeMap</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">interface</span>{}) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">bool</span>)
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeMap</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">interface</span>{}) 
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeMap</span>) <span style="color:#a6e22e">Size</span>() <span style="color:#66d9ef">int</span>
</code></pre></div><p>我们简单的看一下Del的实现即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SafeMap</span>) <span style="color:#a6e22e">Del</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
  
  <span style="color:#75715e">// 从两个map里面删除元素
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyOld</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
		delete(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyOld</span>, <span style="color:#a6e22e">key</span>)
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionOld</span><span style="color:#f92672">++</span>
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
		delete(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span>, <span style="color:#a6e22e">key</span>)
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionNew</span><span style="color:#f92672">++</span>
	}
  
  <span style="color:#75715e">// 其实，如果上面两个ok都是false，可以直接退出了
</span><span style="color:#75715e"></span>  
  <span style="color:#75715e">// 处理 old map，如果 old 的被删除的次数到阈值并且长度小于某个值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionOld</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">maxDeletion</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyOld</span>) &lt; <span style="color:#a6e22e">copyThreshold</span> {
    <span style="color:#75715e">// 1 就将old的所有元素放入new
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyOld</span> {
			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">v</span>
		}
    <span style="color:#75715e">// 2 new 赋值给 old（old整体被释放）
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyOld</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span>
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionOld</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionNew</span>
    
    <span style="color:#75715e">// 3 将new直接初始化
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{})
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionNew</span> = <span style="color:#ae81ff">0</span>
	}
  
  <span style="color:#75715e">// 对 new 也来一遍同样的操作
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionNew</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">maxDeletion</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span>) &lt; <span style="color:#a6e22e">copyThreshold</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span> {
			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyOld</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">v</span>
		}
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyNew</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{})
		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">deletionNew</span> = <span style="color:#ae81ff">0</span>
	}
  
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
}
</code></pre></div><h3 id="set">
  Set
  <a class="anchor" href="#set">#</a>
</h3>
<p>这个也是很简单。</p>
<p>接口定义：</p>
<pre tabindex="0"><code>type Set struct {
	data map[interface{}]lang.PlaceholderType // 就是 struct{}
	tp   int
}

func (s *Set) Add{Type}(ss ...string) 
func (s *Set) Contains(i interface{}) bool 
func (s *Set) Keys() []interface{} 
func (s *Set) Remove(i interface{}) 
func (s *Set) Count() int
</code></pre><p>set 支持各种类型，外加类型检查，要是有泛型，事情就会简单很多。</p>
<p>另外，因为是没有锁的map，是并发不安全的。</p>
<p>实现大家通过看数据结构就能猜到了，就不多讲了。</p>
<h3 id="ring">
  Ring
  <a class="anchor" href="#ring">#</a>
</h3>
<p>类库实现了一个定长环。</p>
<p>接口定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Ring</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">elements</span> []<span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">index</span>    <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Ring</span>) <span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) 
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Ring</span>) <span style="color:#a6e22e">Take</span>() []<span style="color:#66d9ef">interface</span>{} 
</code></pre></div><p>实现本身没有太多的内容，简单描述：</p>
<ul>
<li>每次添加元素，index都前进一格（可能覆盖旧元素）</li>
<li>获取则是从index所在的地方开始，取被设置了的元素。</li>
</ul>
<h3 id="queue">
  Queue
  <a class="anchor" href="#queue">#</a>
</h3>
<p>Queue 是典型的 FIFO 数据类型。</p>
<p>接口定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Queue</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">lock</span>     <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
	<span style="color:#a6e22e">elements</span> []<span style="color:#66d9ef">interface</span>{}
	<span style="color:#a6e22e">size</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">head</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">tail</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">count</span>    <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Queue</span>) <span style="color:#a6e22e">Empty</span>() <span style="color:#66d9ef">bool</span> 
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Queue</span>) <span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">element</span> <span style="color:#66d9ef">interface</span>{}) 
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Queue</span>) <span style="color:#a6e22e">Take</span>() (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">bool</span>) 
</code></pre></div><p>这个其实也是很常规的一种数据结构，简单描述：</p>
<ul>
<li>进队列：如果满了，就扩容size个元素，然后在 elements上追加元素</li>
<li>出队列：如果size为0，直接返回nil；不然就更新head和count，返回元素</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/liuximu/sca/commit/879fc794306f3f6e1e7326fc6a9d668f203e32c5" title='Last modified by liuximu | 2022/02/04' target="_blank" rel="noopener">
      <img src="/SCA/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>2022/02/04</span>
    </a>
  </div>



  <div>
    <a class="flex align-center" href="https://github.com/liuximu/sca/edit/master/content/docs/tal-tech_go-zero/core/03_collection.md" target="_blank" rel="noopener">
      <img src="/SCA/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#集合">集合</a>
      <ul>
        <li>
          <ul>
            <li><a href="#rollingwindow">RollingWindow</a></li>
            <li><a href="#timingwheel">TimingWheel</a></li>
            <li><a href="#safemap">SafeMap</a></li>
            <li><a href="#set">Set</a></li>
            <li><a href="#ring">Ring</a></li>
            <li><a href="#queue">Queue</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












